# Project Specification: Console Todo App

> **Spec-Kit-Plus Specification File v2.0**
> This document defines complete, unambiguous requirements for implementation.
> All code MUST satisfy these specifications exactly.
> This specification is subordinate to `constitution.md` — in case of conflict, the constitution prevails.

---

## Table of Contents

1. [Application Overview](#1-application-overview)
2. [Data Model](#2-data-model)
3. [Persistence Layer](#3-persistence-layer)
4. [User Interface](#4-user-interface)
5. [Feature Specifications](#5-feature-specifications)
6. [Error Handling](#6-error-handling)
7. [Code Structure](#7-code-structure)
8. [Testing Requirements](#8-testing-requirements)
9. [Acceptance Criteria](#9-acceptance-criteria)

---

## 1. Application Overview

### 1.1 Identity

| Attribute | Value |
|-----------|-------|
| Name | Console Todo App |
| Type | Command-Line Interface (CLI) |
| Language | Python 3.10+ |
| Interaction | `input()` and `print()` only |
| Storage | Local JSON file |

### 1.2 Design Principles

1. **Simplicity**: Minimal features, maximum reliability
2. **Data Integrity**: Never lose user data
3. **User Experience**: Clear prompts, helpful errors
4. **Maintainability**: Clean, modular, testable code

### 1.3 Implementation Levels

Features are implemented in strict order. **Level N+1 cannot begin until Level N passes all tests.**

| Level | Name | Status | Features |
|-------|------|--------|----------|
| 1 | Basic (MVP) | Required | Add, List, View, Update, Delete, Toggle, Help, Exit |
| 2 | Intermediate | After L1 | Priority, Tags, Search, Filter, Sort |
| 3 | Advanced | After L2 | Due Dates, Overdue Views, Recurring, Reminders |

---

## 2. Data Model

### 2.1 Task Entity Definition

```python
from dataclasses import dataclass, field
from enum import Enum
from typing import Optional
from datetime import datetime
import uuid


class Priority(Enum):
    """Task priority levels. Ordered for comparison (NONE < LOW < MEDIUM < HIGH)."""
    NONE = 0
    LOW = 1
    MEDIUM = 2
    HIGH = 3


@dataclass
class Task:
    """
    Represents a single todo task.

    Invariants:
    - id is immutable after creation
    - title is never empty after strip()
    - tags are always lowercase
    - created_at <= updated_at
    """
    id: str                              # UUID4 string (36 chars with hyphens)
    title: str                           # 1-200 chars after strip(), required
    description: str = ""                # 0-2000 chars, optional
    completed: bool = False              # Default: False
    priority: Priority = Priority.NONE   # Default: NONE
    tags: list[str] = field(default_factory=list)  # 0-10 tags, each 1-50 chars
    created_at: str = ""                 # ISO 8601: "YYYY-MM-DDTHH:MM:SS"
    updated_at: str = ""                 # ISO 8601: "YYYY-MM-DDTHH:MM:SS"
    due_date: Optional[str] = None       # ISO 8601 date only: "YYYY-MM-DD" or None
    recurring: Optional[str] = None      # "daily" | "weekly" | "monthly" | None
```

### 2.2 Field Specifications

#### 2.2.1 ID Field

| Property | Specification |
|----------|---------------|
| Format | UUID version 4 |
| Example | `"a1b2c3d4-e5f6-7890-abcd-ef1234567890"` |
| Generation | `str(uuid.uuid4())` |
| Display (short) | First 8 characters: `"a1b2c3d4"` |
| Display (full) | All 36 characters |
| User Input | Accept first 4+ characters if unique match |
| Immutability | Cannot be changed after task creation |

**ID Matching Algorithm:**
```
1. User enters partial_id (e.g., "a1b2")
2. Search all tasks where task.id.startswith(partial_id.lower())
3. If exactly 1 match → return that task
4. If 0 matches → raise TaskNotFoundError
5. If 2+ matches → raise AmbiguousIdError("Multiple tasks match. Please be more specific.")
```

#### 2.2.2 Title Field

| Property | Specification |
|----------|---------------|
| Required | Yes |
| Min Length | 1 character (after strip) |
| Max Length | 200 characters |
| Whitespace | Leading/trailing stripped, internal preserved |
| Empty Check | `title.strip() == ""` → ValidationError |

#### 2.2.3 Description Field

| Property | Specification |
|----------|---------------|
| Required | No |
| Default | Empty string `""` |
| Max Length | 2000 characters |
| Whitespace | Leading/trailing stripped |
| Display | "(no description)" if empty |

#### 2.2.4 Priority Field

| Property | Specification |
|----------|---------------|
| Type | `Priority` enum |
| Default | `Priority.NONE` |
| Valid Values | `NONE`, `LOW`, `MEDIUM`, `HIGH` |
| Sort Order | `HIGH > MEDIUM > LOW > NONE` |
| Display | `"-"`, `"LOW"`, `"MED"`, `"HIGH"` |
| JSON Storage | Lowercase string: `null`, `"low"`, `"medium"`, `"high"` |

**Priority Display Mapping:**
```
Priority.NONE   → "-"    (in list), "None"   (in detail view)
Priority.LOW    → "LOW"  (in list), "Low"    (in detail view)
Priority.MEDIUM → "MED"  (in list), "Medium" (in detail view)
Priority.HIGH   → "HIGH" (in list), "High"   (in detail view)
```

#### 2.2.5 Tags Field

| Property | Specification |
|----------|---------------|
| Type | `list[str]` |
| Default | Empty list `[]` |
| Max Tags | 10 per task |
| Tag Length | 1-50 characters each |
| Valid Characters | `a-z`, `0-9`, `-` (lowercase alphanumeric + hyphen) |
| Case | Always stored lowercase |
| Duplicates | Not allowed (case-insensitive check) |
| Display | Comma-separated: `"work, urgent, personal"` |
| Empty Display | "(no tags)" |

**Tag Validation Regex:** `^[a-z0-9][a-z0-9-]{0,49}$`

#### 2.2.6 Date Fields

| Field | Format | Example | Notes |
|-------|--------|---------|-------|
| `created_at` | ISO 8601 datetime | `"2024-01-15T09:30:00"` | Set once on creation |
| `updated_at` | ISO 8601 datetime | `"2024-01-15T14:22:00"` | Updated on any change |
| `due_date` | ISO 8601 date | `"2024-01-20"` | Date only, no time |

**DateTime Generation:**
```python
from datetime import datetime
datetime.now().strftime("%Y-%m-%dT%H:%M:%S")  # "2024-01-15T09:30:00"
```

#### 2.2.7 Recurring Field

| Property | Specification |
|----------|---------------|
| Type | `Optional[str]` |
| Default | `None` |
| Valid Values | `None`, `"daily"`, `"weekly"`, `"monthly"` |
| Requirement | Task MUST have `due_date` set to enable recurring |

### 2.3 Validation Rules Summary

| Field | Validation | Error Message |
|-------|------------|---------------|
| title | Empty after strip | "Error: Title cannot be empty." |
| title | > 200 chars | "Error: Title must be 200 characters or less." |
| description | > 2000 chars | "Error: Description must be 2000 characters or less." |
| priority | Invalid value | "Error: Priority must be one of: none, low, medium, high" |
| tag | Invalid format | "Error: Tags can only contain lowercase letters, numbers, and hyphens." |
| tag | > 50 chars | "Error: Tag must be 50 characters or less." |
| tag | Duplicate | "Error: Tag '{tag}' already exists on this task." |
| tags | > 10 tags | "Error: Maximum 10 tags per task." |
| due_date | Invalid format | "Error: Date must be in YYYY-MM-DD format (e.g., 2024-01-15)." |
| due_date | Invalid date | "Error: Invalid date. Please check month and day values." |
| recurring | No due_date | "Error: Task must have a due date before setting recurrence." |

---

## 3. Persistence Layer

### 3.1 File Locations

```
Project Root/
└── data/
    ├── tasks.json          # Primary data file
    ├── tasks.json.backup   # Auto-backup before each save
    └── tasks.json.tmp      # Temporary file during atomic write
```

**Path Resolution:**
```python
from pathlib import Path
DATA_DIR = Path(__file__).parent.parent / "data"
PRIMARY_FILE = DATA_DIR / "tasks.json"
BACKUP_FILE = DATA_DIR / "tasks.json.backup"
TEMP_FILE = DATA_DIR / "tasks.json.tmp"
```

### 3.2 JSON File Format

```json
{
  "version": "1.0.0",
  "last_modified": "2024-01-15T14:22:00",
  "tasks": [
    {
      "id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
      "title": "Buy groceries",
      "description": "Milk, eggs, bread, vegetables",
      "completed": false,
      "priority": "high",
      "tags": ["shopping", "errands"],
      "created_at": "2024-01-10T09:30:00",
      "updated_at": "2024-01-15T14:22:00",
      "due_date": "2024-01-20",
      "recurring": null
    },
    {
      "id": "b2c3d4e5-f6a7-8901-bcde-f12345678901",
      "title": "Call mom",
      "description": "",
      "completed": true,
      "priority": null,
      "tags": ["family"],
      "created_at": "2024-01-08T10:00:00",
      "updated_at": "2024-01-14T18:30:00",
      "due_date": null,
      "recurring": null
    }
  ]
}
```

### 3.3 Load Behavior (On Application Start)

```
FUNCTION load_tasks():
    1. IF data/ directory does not exist:
        - Create data/ directory
        - PRINT "Created data directory."

    2. IF tasks.json does not exist:
        - Create empty file with: {"version": "1.0.0", "last_modified": "<now>", "tasks": []}
        - PRINT "Created new task list."
        - RETURN empty list

    3. TRY to read and parse tasks.json:
        - Read file content
        - Parse JSON
        - Validate structure (has "version", "tasks" array)
        - Convert each task dict to Task object
        - RETURN list of Task objects

    4. ON JSONDecodeError or KeyError:
        - COPY corrupted file to tasks.json.corrupted.<timestamp>
        - PRINT "Warning: Task file was corrupted. Starting fresh. Corrupted file backed up."
        - Create empty file
        - RETURN empty list

    5. ON PermissionError:
        - PRINT "Error: Cannot read task file. Check file permissions."
        - PRINT "Running in memory-only mode. Changes will not be saved."
        - SET memory_only_mode = True
        - RETURN empty list
```

### 3.4 Save Behavior (On Every Modification)

```
FUNCTION save_tasks(tasks):
    1. IF memory_only_mode:
        - RETURN (do not save)

    2. Prepare data structure:
        data = {
            "version": "1.0.0",
            "last_modified": current_datetime_iso(),
            "tasks": [task.to_dict() for task in tasks]
        }

    3. Write to temporary file:
        - Write JSON to tasks.json.tmp with indent=2
        - Ensure file is flushed and closed

    4. IF write successful:
        - IF tasks.json exists: COPY to tasks.json.backup
        - RENAME tasks.json.tmp to tasks.json (atomic on most systems)

    5. ON ANY error during write:
        - PRINT "Warning: Could not save tasks. Your changes may be lost."
        - DELETE tasks.json.tmp if exists
        - DO NOT exit application
        - RETURN False

    6. RETURN True
```

### 3.5 Serialization Rules

**Task to Dict (for JSON storage):**
```python
def to_dict(self) -> dict:
    return {
        "id": self.id,
        "title": self.title,
        "description": self.description,
        "completed": self.completed,
        "priority": self.priority.name.lower() if self.priority != Priority.NONE else None,
        "tags": self.tags,
        "created_at": self.created_at,
        "updated_at": self.updated_at,
        "due_date": self.due_date,
        "recurring": self.recurring
    }
```

**Dict to Task (from JSON storage):**
```python
@classmethod
def from_dict(cls, data: dict) -> "Task":
    priority_str = data.get("priority")
    if priority_str is None:
        priority = Priority.NONE
    else:
        priority = Priority[priority_str.upper()]

    return cls(
        id=data["id"],
        title=data["title"],
        description=data.get("description", ""),
        completed=data.get("completed", False),
        priority=priority,
        tags=data.get("tags", []),
        created_at=data["created_at"],
        updated_at=data["updated_at"],
        due_date=data.get("due_date"),
        recurring=data.get("recurring")
    )
```

---

## 4. User Interface

### 4.1 Application Startup Sequence

```
1. Display welcome banner
2. Load tasks from file
3. IF Advanced Level implemented AND (overdue_tasks OR due_today_tasks):
   - Display reminder panel
   - Wait for Enter key
4. Display main menu
5. Enter main loop
```

**Welcome Banner:**
```
================================================================================
                          CONSOLE TODO APP v1.0.0
================================================================================
```

**Reminder Panel (Advanced Level Only):**
```
┌──────────────────────────────────────────────────────────────────────────────┐
│                              ⚠ REMINDERS                                     │
├──────────────────────────────────────────────────────────────────────────────┤
│  OVERDUE (2 tasks):                                                          │
│    • a1b2c3d4 - Buy groceries (was due 2024-01-10)                          │
│    • b2c3d4e5 - Pay bills (was due 2024-01-12)                              │
│                                                                              │
│  DUE TODAY (1 task):                                                         │
│    • c3d4e5f6 - Submit report                                               │
└──────────────────────────────────────────────────────────────────────────────┘
Press Enter to continue...
```

### 4.2 Main Menu

**Level 1 (Basic) Menu:**
```
================================================================================
                                 MAIN MENU
================================================================================
  1. Add task              5. Delete task
  2. List all tasks        6. Mark complete/incomplete
  3. View task details
  4. Update task           0. Exit
                           h. Help
--------------------------------------------------------------------------------
Enter choice:
```

**Level 2 (Intermediate) Menu - Adds options 7-12:**
```
================================================================================
                                 MAIN MENU
================================================================================
  BASIC                         ORGANIZE
  1. Add task                   7. Set priority
  2. List all tasks             8. Add tag
  3. View task details          9. Remove tag
  4. Update task
  5. Delete task                FIND
  6. Mark complete/incomplete   10. Search tasks
                                11. Filter tasks
  SYSTEM                        12. Sort tasks
  0. Exit
  h. Help
--------------------------------------------------------------------------------
Enter choice:
```

**Level 3 (Advanced) Menu - Adds options 13-17:**
```
================================================================================
                                 MAIN MENU
================================================================================
  BASIC                         ORGANIZE                    DATES
  1. Add task                   7. Set priority             13. Set due date
  2. List all tasks             8. Add tag                  14. Clear due date
  3. View task details          9. Remove tag               15. Show overdue
  4. Update task                                            16. Show due today
  5. Delete task                FIND                        17. Show due this week
  6. Mark complete/incomplete   10. Search tasks            18. Set recurring
                                11. Filter tasks
  SYSTEM                        12. Sort tasks
  0. Exit
  h. Help
--------------------------------------------------------------------------------
Enter choice:
```

### 4.3 Menu Input Handling

**Valid Inputs:**
- `0` through `18` (depending on level)
- `h` or `H` or `help` for help
- `q` or `Q` or `quit` or `exit` (alias for 0)

**Invalid Input Response:**
```
Invalid choice. Please enter a number from the menu or 'h' for help.
```

**Main Loop Logic:**
```
WHILE True:
    display_menu()
    choice = input("Enter choice: ").strip().lower()

    IF choice in ["0", "q", "quit", "exit"]:
        confirm_and_exit()
    ELSE IF choice in ["h", "help"]:
        display_help()
    ELSE IF choice.isdigit() AND 1 <= int(choice) <= max_option:
        execute_command(int(choice))
    ELSE:
        PRINT "Invalid choice. Please enter a number from the menu or 'h' for help."

    PRINT ""  # Blank line before next menu
```

### 4.4 Task List Display Format

**Standard List View (Option 2):**
```
================================================================================
                        TASKS (5 total, 2 completed)
================================================================================
ID        STATUS  PRI   TITLE                               DUE        TAGS
--------------------------------------------------------------------------------
a1b2c3d4  [ ]     HIGH  Buy groceries                       2024-01-20 shopping
b2c3d4e5  [x]     -     Call mom                            -          family
c3d4e5f6  [ ]     MED   Finish quarterly report             Today      work, urgent
d4e5f6a7  [ ]     LOW   Read "Clean Code" book              2024-01-25 personal
e5f6a7b8  [x]     -     Submit timesheet                    -          work
================================================================================
Legend: [x] = Completed  [ ] = Pending  |  HIGH/MED/LOW/- = Priority
```

**Column Specifications:**
| Column | Width | Alignment | Content |
|--------|-------|-----------|---------|
| ID | 8 | Left | First 8 chars of UUID |
| STATUS | 6 | Center | `[x]` or `[ ]` |
| PRI | 4 | Left | `HIGH`, `MED`, `LOW`, or `-` |
| TITLE | 35 | Left | Truncate with `...` if > 35 |
| DUE | 10 | Left | `YYYY-MM-DD`, `Today`, `Tomorrow`, or `-` |
| TAGS | Remaining | Left | First 2-3 tags, `+N more` if truncated |

**Due Date Display Logic:**
```python
def format_due_date(due_date: Optional[str], today: date) -> str:
    if due_date is None:
        return "-"
    due = date.fromisoformat(due_date)
    if due == today:
        return "Today"
    elif due == today + timedelta(days=1):
        return "Tomorrow"
    elif due < today:
        return f"OVERDUE"  # Or show date with indicator
    else:
        return due_date  # "YYYY-MM-DD"
```

**Empty List Display:**
```
================================================================================
                              TASKS (0 total)
================================================================================

  No tasks yet! Use option 1 to add your first task.

================================================================================
```

### 4.5 Task Detail View Format

**Single Task View (Option 3):**
```
================================================================================
                              TASK DETAILS
================================================================================
ID:          a1b2c3d4-e5f6-7890-abcd-ef1234567890
Title:       Buy groceries
Description: Milk, eggs, bread, and fresh vegetables for the week
Status:      Pending
Priority:    High
Tags:        shopping, errands
Due Date:    2024-01-20 (in 5 days)
Recurring:   Weekly
Created:     2024-01-10 09:30:00
Updated:     2024-01-15 14:22:00
================================================================================
```

**Field Display When Empty/None:**
```
Description: (no description)
Tags:        (no tags)
Due Date:    Not set
Recurring:   Not set
```

### 4.6 Input Prompts

**Standard Prompt Format:**
```
{Field name}:
```

**With Default/Skip Option:**
```
{Field name} (press Enter to skip):
{Field name} (press Enter to keep "{current_value}"):
```

**Confirmation Prompt Format:**
```
{Action description}? (y/N):
```
- Only `y` or `Y` confirms
- Any other input (including Enter) = No
- Capital `N` indicates default is No

### 4.7 Message Types

| Type | Prefix | Example |
|------|--------|---------|
| Success | (none) | `Task added successfully! ID: a1b2c3d4` |
| Error | `Error: ` | `Error: Title cannot be empty.` |
| Warning | `Warning: ` | `Warning: This date is in the past.` |
| Info | (none) | `Found 3 matching tasks.` |
| Confirmation | (none) | `Delete task "Buy groceries"? (y/N): ` |

---

## 5. Feature Specifications

### 5.1 Level 1: Basic Features

#### Feature B1: Add Task (Option 1)

**Flow:**
```
PRINT "--- Add New Task ---"
PRINT ""

PROMPT "Title: "
READ title
title = title.strip()

IF title == "":
    PRINT "Error: Title cannot be empty."
    RETURN to menu

IF len(title) > 200:
    PRINT "Error: Title must be 200 characters or less."
    RETURN to menu

PROMPT "Description (press Enter to skip): "
READ description
description = description.strip()

IF len(description) > 2000:
    PRINT "Error: Description must be 2000 characters or less."
    RETURN to menu

task = create_task(title, description)
save_tasks()

PRINT ""
PRINT f"Task added successfully! ID: {task.id[:8]}"
```

**Test Cases:**
- Valid title only → Task created with empty description
- Valid title + description → Task created with both
- Empty title → Error, no task created
- Title with only whitespace → Error, no task created
- Title 200 chars → Success
- Title 201 chars → Error
- Description 2000 chars → Success
- Description 2001 chars → Error

#### Feature B2: List All Tasks (Option 2)

**Flow:**
```
tasks = get_all_tasks()

IF len(tasks) == 0:
    display_empty_list_message()
    RETURN

completed_count = count tasks where completed == True
PRINT formatted_task_list(tasks, total=len(tasks), completed=completed_count)
```

**Display Rules:**
- Sort by: created_at descending (newest first) by default
- Show all tasks (no pagination in Level 1)
- Truncate title at 35 chars with "..."
- Show first 8 chars of ID

#### Feature B3: View Task Details (Option 3)

**Flow:**
```
PRINT "--- View Task ---"
PRINT ""

PROMPT "Enter task ID: "
READ task_id
task_id = task_id.strip().lower()

IF task_id == "":
    PRINT "Error: Task ID cannot be empty."
    RETURN to menu

task = find_task_by_id(task_id)  # Partial match allowed

IF task is None:
    PRINT f"Error: No task found matching '{task_id}'."
    RETURN to menu

display_task_details(task)
```

**Partial ID Matching:**
```python
def find_task_by_id(partial_id: str) -> Task | None:
    matches = [t for t in tasks if t.id.lower().startswith(partial_id.lower())]
    if len(matches) == 0:
        return None  # Not found
    if len(matches) == 1:
        return matches[0]
    # Multiple matches
    raise AmbiguousIdError(f"Multiple tasks match '{partial_id}'. Please be more specific.")
```

#### Feature B4: Update Task (Option 4)

**Flow:**
```
PRINT "--- Update Task ---"
PRINT ""

PROMPT "Enter task ID: "
READ task_id
task = find_task_by_id(task_id)

IF task is None:
    PRINT f"Error: No task found matching '{task_id}'."
    RETURN to menu

PRINT ""
PRINT f"Current title: {task.title}"
PROMPT f"New title (press Enter to keep current): "
READ new_title

IF new_title.strip() != "":
    IF len(new_title.strip()) > 200:
        PRINT "Error: Title must be 200 characters or less."
        RETURN to menu
    task.title = new_title.strip()

PRINT ""
PRINT f"Current description: {task.description or '(no description)'}"
PROMPT "New description (press Enter to keep current, '-' to clear): "
READ new_description

IF new_description == "-":
    task.description = ""
ELSE IF new_description.strip() != "":
    IF len(new_description.strip()) > 2000:
        PRINT "Error: Description must be 2000 characters or less."
        RETURN to menu
    task.description = new_description.strip()

task.updated_at = current_datetime_iso()
save_tasks()

PRINT ""
PRINT "Task updated successfully!"
```

**Special Input:**
- Enter (empty): Keep current value
- `-`: Clear the field (set to empty string)

#### Feature B5: Delete Task (Option 5)

**Flow:**
```
PRINT "--- Delete Task ---"
PRINT ""

PROMPT "Enter task ID: "
READ task_id
task = find_task_by_id(task_id)

IF task is None:
    PRINT f"Error: No task found matching '{task_id}'."
    RETURN to menu

PRINT ""
PROMPT f"Delete task \"{task.title}\"? This cannot be undone. (y/N): "
READ confirmation

IF confirmation.lower() != "y":
    PRINT "Delete cancelled."
    RETURN to menu

delete_task(task.id)
save_tasks()

PRINT ""
PRINT "Task deleted successfully."
```

#### Feature B6: Toggle Complete/Incomplete (Option 6)

**Flow:**
```
PRINT "--- Toggle Task Status ---"
PRINT ""

PROMPT "Enter task ID: "
READ task_id
task = find_task_by_id(task_id)

IF task is None:
    PRINT f"Error: No task found matching '{task_id}'."
    RETURN to menu

old_status = task.completed
task.completed = NOT task.completed
task.updated_at = current_datetime_iso()

# Handle recurring task completion (Level 3 only)
IF old_status == False AND task.completed == True AND task.recurring is not None:
    new_task = create_recurring_instance(task)
    PRINT ""
    PRINT f"Recurring task: New instance created with ID {new_task.id[:8]}"

save_tasks()

status_word = "completed" IF task.completed ELSE "pending"
PRINT ""
PRINT f"Task \"{task.title}\" marked as {status_word}."
```

#### Feature B7: Help (Option h)

**Flow:**
```
PRINT "================================================================================
                                   HELP
================================================================================

COMMANDS:
  1  - Add a new task
  2  - List all tasks
  3  - View task details (shows all information for one task)
  4  - Update a task (change title or description)
  5  - Delete a task (permanent, requires confirmation)
  6  - Toggle complete/incomplete status

  0  - Exit the application
  h  - Show this help message

TIPS:
  • Task IDs can be entered partially (first 4+ characters if unique)
  • When updating, press Enter to keep current value, or '-' to clear
  • Use 'list' to see all task IDs before other operations

================================================================================
Press Enter to continue..."
```

#### Feature B8: Exit (Option 0)

**Flow:**
```
PRINT ""
PRINT "Goodbye! Your tasks have been saved."
sys.exit(0)
```

**Note:** No confirmation needed for exit since data is saved after every operation.

---

### 5.2 Level 2: Intermediate Features

#### Feature I1: Set Priority (Option 7)

**Flow:**
```
PRINT "--- Set Task Priority ---"
PRINT ""

PROMPT "Enter task ID: "
READ task_id
task = find_task_by_id(task_id)

IF task is None:
    PRINT f"Error: No task found matching '{task_id}'."
    RETURN to menu

PRINT ""
PRINT f"Current priority: {format_priority(task.priority)}"
PRINT ""
PRINT "Select new priority:"
PRINT "  1. High"
PRINT "  2. Medium"
PRINT "  3. Low"
PRINT "  4. None (remove priority)"
PRINT ""
PROMPT "Choice (1-4): "
READ choice

priority_map = {"1": Priority.HIGH, "2": Priority.MEDIUM, "3": Priority.LOW, "4": Priority.NONE}

IF choice not in priority_map:
    PRINT "Error: Please enter 1, 2, 3, or 4."
    RETURN to menu

task.priority = priority_map[choice]
task.updated_at = current_datetime_iso()
save_tasks()

PRINT ""
PRINT f"Priority set to {format_priority(task.priority)}."
```

#### Feature I2: Add Tag (Option 8)

**Flow:**
```
PRINT "--- Add Tag ---"
PRINT ""

PROMPT "Enter task ID: "
READ task_id
task = find_task_by_id(task_id)

IF task is None:
    PRINT f"Error: No task found matching '{task_id}'."
    RETURN to menu

PRINT ""
IF len(task.tags) > 0:
    PRINT f"Current tags: {', '.join(task.tags)}"
ELSE:
    PRINT "Current tags: (none)"

IF len(task.tags) >= 10:
    PRINT ""
    PRINT "Error: Maximum 10 tags per task."
    RETURN to menu

PRINT ""
PROMPT "Enter tag to add: "
READ tag
tag = tag.strip().lower()

IF tag == "":
    PRINT "Error: Tag cannot be empty."
    RETURN to menu

IF NOT re.match(r"^[a-z0-9][a-z0-9-]{0,49}$", tag):
    PRINT "Error: Tags can only contain lowercase letters, numbers, and hyphens (1-50 chars)."
    RETURN to menu

IF tag in task.tags:
    PRINT f"Error: Tag '{tag}' already exists on this task."
    RETURN to menu

task.tags.append(tag)
task.updated_at = current_datetime_iso()
save_tasks()

PRINT ""
PRINT f"Tag '{tag}' added."
```

#### Feature I3: Remove Tag (Option 9)

**Flow:**
```
PRINT "--- Remove Tag ---"
PRINT ""

PROMPT "Enter task ID: "
READ task_id
task = find_task_by_id(task_id)

IF task is None:
    PRINT f"Error: No task found matching '{task_id}'."
    RETURN to menu

IF len(task.tags) == 0:
    PRINT ""
    PRINT "Error: This task has no tags."
    RETURN to menu

PRINT ""
PRINT "Current tags:"
FOR i, tag IN enumerate(task.tags, 1):
    PRINT f"  {i}. {tag}"

PRINT ""
PROMPT "Enter tag name or number to remove: "
READ input_value
input_value = input_value.strip()

# Check if it's a number
IF input_value.isdigit():
    index = int(input_value) - 1
    IF 0 <= index < len(task.tags):
        tag_to_remove = task.tags[index]
    ELSE:
        PRINT "Error: Invalid tag number."
        RETURN to menu
ELSE:
    # It's a tag name
    tag_to_remove = input_value.lower()
    IF tag_to_remove not in task.tags:
        PRINT f"Error: Tag '{tag_to_remove}' not found on this task."
        RETURN to menu

task.tags.remove(tag_to_remove)
task.updated_at = current_datetime_iso()
save_tasks()

PRINT ""
PRINT f"Tag '{tag_to_remove}' removed."
```

#### Feature I4: Search Tasks (Option 10)

**Flow:**
```
PRINT "--- Search Tasks ---"
PRINT ""

PROMPT "Enter search query (min 2 characters): "
READ query
query = query.strip()

IF len(query) < 2:
    PRINT "Error: Search query must be at least 2 characters."
    RETURN to menu

results = search_tasks(query)

IF len(results) == 0:
    PRINT ""
    PRINT f"No tasks found matching '{query}'."
    RETURN to menu

PRINT ""
PRINT f"Found {len(results)} task(s) matching '{query}':"
display_task_list(results)
```

**Search Algorithm:**
```python
def search_tasks(query: str) -> list[Task]:
    query_lower = query.lower()
    results = []

    for task in all_tasks:
        # Check title (higher priority)
        if query_lower in task.title.lower():
            results.append((task, 1))  # Priority 1 = title match
        # Check description
        elif query_lower in task.description.lower():
            results.append((task, 2))  # Priority 2 = description match
        # Check tags
        elif any(query_lower in tag for tag in task.tags):
            results.append((task, 3))  # Priority 3 = tag match

    # Sort by match priority, then by created_at descending
    results.sort(key=lambda x: (x[1], -parse_datetime(x[0].created_at).timestamp()))
    return [task for task, _ in results]
```

#### Feature I5: Filter Tasks (Option 11)

**Flow:**
```
PRINT "--- Filter Tasks ---"
PRINT ""
PRINT "Filter by:"
PRINT "  1. Status"
PRINT "  2. Priority"
PRINT "  3. Tag"
PRINT "  4. Show all (clear filter)"
PRINT ""
PROMPT "Choice (1-4): "
READ choice

IF choice == "1":
    filter_by_status()
ELSE IF choice == "2":
    filter_by_priority()
ELSE IF choice == "3":
    filter_by_tag()
ELSE IF choice == "4":
    show_all_tasks()
ELSE:
    PRINT "Error: Please enter 1, 2, 3, or 4."
```

**Filter by Status Sub-flow:**
```
PRINT ""
PRINT "Show tasks that are:"
PRINT "  1. Pending (not completed)"
PRINT "  2. Completed"
PRINT ""
PROMPT "Choice (1-2): "
READ status_choice

IF status_choice == "1":
    results = [t for t in all_tasks if not t.completed]
    PRINT ""
    PRINT f"Pending tasks ({len(results)}):"
ELSE IF status_choice == "2":
    results = [t for t in all_tasks if t.completed]
    PRINT ""
    PRINT f"Completed tasks ({len(results)}):"
ELSE:
    PRINT "Error: Please enter 1 or 2."
    RETURN

display_task_list(results)
```

**Filter by Priority Sub-flow:**
```
PRINT ""
PRINT "Show tasks with priority:"
PRINT "  1. High"
PRINT "  2. Medium"
PRINT "  3. Low"
PRINT "  4. None"
PRINT ""
PROMPT "Choice (1-4): "
READ priority_choice

priority_map = {"1": Priority.HIGH, "2": Priority.MEDIUM, "3": Priority.LOW, "4": Priority.NONE}

IF priority_choice not in priority_map:
    PRINT "Error: Please enter 1, 2, 3, or 4."
    RETURN

selected_priority = priority_map[priority_choice]
results = [t for t in all_tasks if t.priority == selected_priority]

PRINT ""
PRINT f"Tasks with {format_priority(selected_priority)} priority ({len(results)}):"
display_task_list(results)
```

**Filter by Tag Sub-flow:**
```
# Collect all unique tags
all_tags = sorted(set(tag for task in all_tasks for tag in task.tags))

IF len(all_tags) == 0:
    PRINT ""
    PRINT "No tags found in any tasks."
    RETURN

PRINT ""
PRINT "Available tags:"
FOR i, tag IN enumerate(all_tags, 1):
    PRINT f"  {i}. {tag}"

PRINT ""
PROMPT "Enter tag name or number: "
READ tag_input
tag_input = tag_input.strip()

IF tag_input.isdigit():
    index = int(tag_input) - 1
    IF 0 <= index < len(all_tags):
        selected_tag = all_tags[index]
    ELSE:
        PRINT "Error: Invalid tag number."
        RETURN
ELSE:
    selected_tag = tag_input.lower()

results = [t for t in all_tasks if selected_tag in t.tags]

PRINT ""
PRINT f"Tasks tagged '{selected_tag}' ({len(results)}):"
display_task_list(results)
```

#### Feature I6: Sort Tasks (Option 12)

**Flow:**
```
PRINT "--- Sort Tasks ---"
PRINT ""
PRINT "Sort by:"
PRINT "  1. Priority (high to low)"
PRINT "  2. Priority (low to high)"
PRINT "  3. Due date (earliest first)"
PRINT "  4. Due date (latest first)"
PRINT "  5. Title (A-Z)"
PRINT "  6. Title (Z-A)"
PRINT "  7. Created (newest first)"
PRINT "  8. Created (oldest first)"
PRINT ""
PROMPT "Choice (1-8): "
READ choice

sort_functions = {
    "1": lambda t: (-t.priority.value, t.title.lower()),
    "2": lambda t: (t.priority.value, t.title.lower()),
    "3": lambda t: (t.due_date or "9999-99-99", t.title.lower()),
    "4": lambda t: (("0000-00-00" if t.due_date is None else "") + (t.due_date or ""), t.title.lower()),
    "5": lambda t: t.title.lower(),
    "6": lambda t: t.title.lower(),  # Will reverse
    "7": lambda t: t.created_at,     # Will reverse
    "8": lambda t: t.created_at,
}

reverse_choices = {"4", "6", "7"}

IF choice not in sort_functions:
    PRINT "Error: Please enter a number from 1 to 8."
    RETURN

sorted_tasks = sorted(all_tasks, key=sort_functions[choice], reverse=(choice in reverse_choices))

PRINT ""
PRINT f"Tasks sorted by {sort_description[choice]}:"
display_task_list(sorted_tasks)
```

**Sort Null Handling:**
- `None` due dates sort LAST when sorting earliest first
- `None` due dates sort LAST when sorting latest first
- `Priority.NONE` sorts as lowest value

---

### 5.3 Level 3: Advanced Features

#### Feature A1: Set Due Date (Option 13)

**Flow:**
```
PRINT "--- Set Due Date ---"
PRINT ""

PROMPT "Enter task ID: "
READ task_id
task = find_task_by_id(task_id)

IF task is None:
    PRINT f"Error: No task found matching '{task_id}'."
    RETURN to menu

PRINT ""
IF task.due_date:
    PRINT f"Current due date: {task.due_date}"
ELSE:
    PRINT "Current due date: Not set"

PRINT ""
PROMPT "Enter due date (YYYY-MM-DD): "
READ date_input
date_input = date_input.strip()

IF date_input == "":
    PRINT "Error: Date cannot be empty. Use option 14 to clear due date."
    RETURN to menu

# Validate date format
TRY:
    parsed_date = datetime.strptime(date_input, "%Y-%m-%d").date()
EXCEPT ValueError:
    PRINT "Error: Date must be in YYYY-MM-DD format (e.g., 2024-01-15)."
    RETURN to menu

# Check if date is in the past
today = date.today()
IF parsed_date < today:
    PRINT ""
    PROMPT "Warning: This date is in the past. Set anyway? (y/N): "
    READ confirmation
    IF confirmation.lower() != "y":
        PRINT "Due date not changed."
        RETURN to menu

task.due_date = date_input
task.updated_at = current_datetime_iso()
save_tasks()

# Calculate days until due
days_diff = (parsed_date - today).days
IF days_diff == 0:
    relative = "(today)"
ELSE IF days_diff == 1:
    relative = "(tomorrow)"
ELSE IF days_diff > 0:
    relative = f"(in {days_diff} days)"
ELSE:
    relative = f"({abs(days_diff)} days ago)"

PRINT ""
PRINT f"Due date set to {date_input} {relative}."
```

#### Feature A2: Clear Due Date (Option 14)

**Flow:**
```
PRINT "--- Clear Due Date ---"
PRINT ""

PROMPT "Enter task ID: "
READ task_id
task = find_task_by_id(task_id)

IF task is None:
    PRINT f"Error: No task found matching '{task_id}'."
    RETURN to menu

IF task.due_date is None:
    PRINT ""
    PRINT "This task doesn't have a due date set."
    RETURN to menu

# Check if task has recurring set
IF task.recurring is not None:
    PRINT ""
    PRINT "Warning: This task has recurrence set. Clearing due date will also remove recurrence."
    PROMPT "Continue? (y/N): "
    READ confirmation
    IF confirmation.lower() != "y":
        PRINT "Due date not changed."
        RETURN to menu
    task.recurring = None

task.due_date = None
task.updated_at = current_datetime_iso()
save_tasks()

PRINT ""
PRINT "Due date cleared."
```

#### Feature A3: Show Overdue Tasks (Option 15)

**Flow:**
```
today = date.today()
overdue = [t for t in all_tasks
           if t.due_date is not None
           and date.fromisoformat(t.due_date) < today
           and not t.completed]

PRINT ""
IF len(overdue) == 0:
    PRINT "No overdue tasks. Great job!"
ELSE:
    PRINT f"OVERDUE TASKS ({len(overdue)}):"
    PRINT ""
    display_task_list(overdue, highlight_overdue=True)
```

#### Feature A4: Show Due Today (Option 16)

**Flow:**
```
today = date.today().isoformat()
due_today = [t for t in all_tasks
             if t.due_date == today
             and not t.completed]

PRINT ""
IF len(due_today) == 0:
    PRINT "No tasks due today."
ELSE:
    PRINT f"TASKS DUE TODAY ({len(due_today)}):"
    PRINT ""
    display_task_list(due_today)
```

#### Feature A5: Show Due This Week (Option 17)

**Flow:**
```
today = date.today()
week_end = today + timedelta(days=7)

due_this_week = [t for t in all_tasks
                 if t.due_date is not None
                 and today <= date.fromisoformat(t.due_date) <= week_end
                 and not t.completed]

# Sort by due date
due_this_week.sort(key=lambda t: t.due_date)

PRINT ""
IF len(due_this_week) == 0:
    PRINT "No tasks due in the next 7 days."
ELSE:
    PRINT f"TASKS DUE THIS WEEK ({len(due_this_week)}):"
    PRINT ""
    display_task_list(due_this_week)
```

#### Feature A6: Set Recurring (Option 18)

**Flow:**
```
PRINT "--- Set Recurring ---"
PRINT ""

PROMPT "Enter task ID: "
READ task_id
task = find_task_by_id(task_id)

IF task is None:
    PRINT f"Error: No task found matching '{task_id}'."
    RETURN to menu

IF task.due_date is None:
    PRINT ""
    PRINT "Error: Task must have a due date before setting recurrence."
    PRINT "Use option 13 to set a due date first."
    RETURN to menu

PRINT ""
IF task.recurring:
    PRINT f"Current recurrence: {task.recurring.capitalize()}"
ELSE:
    PRINT "Current recurrence: Not set"

PRINT ""
PRINT "Set recurrence pattern:"
PRINT "  1. Daily"
PRINT "  2. Weekly"
PRINT "  3. Monthly"
PRINT "  4. Remove recurrence"
PRINT ""
PROMPT "Choice (1-4): "
READ choice

recurrence_map = {"1": "daily", "2": "weekly", "3": "monthly", "4": None}

IF choice not in recurrence_map:
    PRINT "Error: Please enter 1, 2, 3, or 4."
    RETURN to menu

task.recurring = recurrence_map[choice]
task.updated_at = current_datetime_iso()
save_tasks()

IF task.recurring:
    PRINT ""
    PRINT f"Task will recur {task.recurring}."
    PRINT "A new task will be created when this one is marked complete."
ELSE:
    PRINT ""
    PRINT "Recurrence removed."
```

#### Feature A7: Recurring Task Completion Logic

**Triggered by Feature B6 when completing a recurring task:**

```python
def create_recurring_instance(original_task: Task) -> Task:
    """Create a new task instance when a recurring task is completed."""

    # Calculate new due date
    original_due = date.fromisoformat(original_task.due_date)

    if original_task.recurring == "daily":
        new_due = original_due + timedelta(days=1)
    elif original_task.recurring == "weekly":
        new_due = original_due + timedelta(weeks=1)
    elif original_task.recurring == "monthly":
        # Add one month (handle month overflow)
        year = original_due.year
        month = original_due.month + 1
        if month > 12:
            month = 1
            year += 1
        # Handle day overflow (e.g., Jan 31 -> Feb 28)
        day = min(original_due.day, calendar.monthrange(year, month)[1])
        new_due = date(year, month, day)

    # Create new task
    new_task = Task(
        id=str(uuid.uuid4()),
        title=original_task.title,
        description=original_task.description,
        completed=False,
        priority=original_task.priority,
        tags=original_task.tags.copy(),
        created_at=current_datetime_iso(),
        updated_at=current_datetime_iso(),
        due_date=new_due.isoformat(),
        recurring=original_task.recurring
    )

    add_task(new_task)
    return new_task
```

---

## 6. Error Handling

### 6.1 Exception Hierarchy

```python
class TodoAppError(Exception):
    """Base exception for all application errors."""
    pass

class ValidationError(TodoAppError):
    """Raised when user input fails validation."""
    pass

class TaskNotFoundError(TodoAppError):
    """Raised when a task ID doesn't match any task."""
    pass

class AmbiguousIdError(TodoAppError):
    """Raised when a partial task ID matches multiple tasks."""
    pass

class StorageError(TodoAppError):
    """Raised when file operations fail."""
    pass
```

### 6.2 Error Messages Catalog

| Error Code | Condition | Message |
|------------|-----------|---------|
| E001 | Empty title | "Error: Title cannot be empty." |
| E002 | Title too long | "Error: Title must be 200 characters or less." |
| E003 | Description too long | "Error: Description must be 2000 characters or less." |
| E004 | Task not found | "Error: No task found matching '{id}'." |
| E005 | Ambiguous ID | "Error: Multiple tasks match '{id}'. Please be more specific." |
| E006 | Invalid priority | "Error: Priority must be one of: none, low, medium, high" |
| E007 | Invalid tag format | "Error: Tags can only contain lowercase letters, numbers, and hyphens." |
| E008 | Tag too long | "Error: Tag must be 50 characters or less." |
| E009 | Duplicate tag | "Error: Tag '{tag}' already exists on this task." |
| E010 | Max tags reached | "Error: Maximum 10 tags per task." |
| E011 | Tag not found | "Error: Tag '{tag}' not found on this task." |
| E012 | No tags | "Error: This task has no tags." |
| E013 | Invalid date format | "Error: Date must be in YYYY-MM-DD format (e.g., 2024-01-15)." |
| E014 | Invalid date value | "Error: Invalid date. Please check month and day values." |
| E015 | No due date for recurring | "Error: Task must have a due date before setting recurrence." |
| E016 | Search too short | "Error: Search query must be at least 2 characters." |
| E017 | Invalid menu choice | "Invalid choice. Please enter a number from the menu or 'h' for help." |
| E018 | File permission | "Error: Cannot read task file. Check file permissions." |
| E019 | Save failed | "Warning: Could not save tasks. Your changes may be lost." |
| E020 | Empty ID | "Error: Task ID cannot be empty." |

### 6.3 Error Recovery Strategies

| Scenario | Detection | Recovery Action |
|----------|-----------|-----------------|
| File not found | `FileNotFoundError` | Create new empty file, continue |
| File corrupted | `json.JSONDecodeError` | Backup file, create new, warn user |
| Permission denied | `PermissionError` | Set memory-only mode, warn user |
| Write failed | Any exception during save | Keep original file, warn user, continue |
| Keyboard interrupt | `KeyboardInterrupt` | Save current state, exit gracefully |

### 6.4 Graceful Interrupt Handling

```python
import signal
import sys

def handle_interrupt(signum, frame):
    print("\n\nInterrupted. Saving tasks...")
    save_tasks()
    print("Goodbye!")
    sys.exit(0)

signal.signal(signal.SIGINT, handle_interrupt)
```

---

## 7. Code Structure

### 7.1 Directory Layout

```
to-do-app/
├── main.py                      # Entry point (< 50 lines)
├── constitution.md              # Project governance rules
├── .specify                     # This specification file
├── src/
│   ├── __init__.py              # Package marker
│   ├── app.py                   # Application class, main loop
│   ├── models/
│   │   ├── __init__.py          # Exports: Task, Priority
│   │   ├── task.py              # Task dataclass
│   │   └── priority.py          # Priority enum
│   ├── services/
│   │   ├── __init__.py          # Exports: TaskService, StorageService
│   │   ├── task_service.py      # Business logic (CRUD, search, filter, sort)
│   │   └── storage_service.py   # JSON file operations
│   ├── ui/
│   │   ├── __init__.py          # Exports: Menu, Display, InputHandler
│   │   ├── menu.py              # Menu display and command routing
│   │   ├── display.py           # Output formatting functions
│   │   └── input_handler.py     # Input prompts and validation
│   ├── utils/
│   │   ├── __init__.py          # Exports: validators, date_utils, constants
│   │   ├── validators.py        # Validation functions
│   │   ├── date_utils.py        # Date parsing and formatting
│   │   └── constants.py         # All magic values and config
│   └── exceptions.py            # Custom exception classes
├── tests/
│   ├── __init__.py
│   ├── conftest.py              # Pytest fixtures
│   ├── test_task.py             # Task model tests
│   ├── test_priority.py         # Priority enum tests
│   ├── test_task_service.py     # TaskService tests
│   ├── test_storage_service.py  # StorageService tests
│   ├── test_validators.py       # Validator tests
│   ├── test_date_utils.py       # Date utility tests
│   └── test_integration.py      # End-to-end tests
├── data/
│   └── .gitkeep                 # Ensure directory exists in repo
└── README.md                    # User documentation
```

### 7.2 Module Specifications

#### main.py (Entry Point)

```python
#!/usr/bin/env python3
"""Console Todo App - Entry Point"""

from src.app import TodoApp


def main() -> None:
    """Initialize and run the application."""
    app = TodoApp()
    app.run()


if __name__ == "__main__":
    main()
```

#### src/app.py (Application Class)

```python
"""Main application class."""

from src.services import TaskService, StorageService
from src.ui import Menu


class TodoApp:
    """Main application orchestrator."""

    def __init__(self, data_file: str = "data/tasks.json") -> None:
        self.storage = StorageService(data_file)
        self.task_service = TaskService(self.storage)
        self.menu = Menu(self.task_service)

    def run(self) -> None:
        """Start the main application loop."""
        self._display_welcome()
        self._check_reminders()
        self.menu.main_loop()

    def _display_welcome(self) -> None: ...
    def _check_reminders(self) -> None: ...
```

#### src/models/task.py

```python
"""Task model definition."""

from dataclasses import dataclass, field
from datetime import datetime
from typing import Optional
import uuid

from .priority import Priority


@dataclass
class Task:
    """Represents a single todo task."""

    id: str
    title: str
    description: str = ""
    completed: bool = False
    priority: Priority = Priority.NONE
    tags: list[str] = field(default_factory=list)
    created_at: str = ""
    updated_at: str = ""
    due_date: Optional[str] = None
    recurring: Optional[str] = None

    def __post_init__(self) -> None:
        """Set timestamps if not provided."""
        now = datetime.now().strftime("%Y-%m-%dT%H:%M:%S")
        if not self.created_at:
            self.created_at = now
        if not self.updated_at:
            self.updated_at = now

    @classmethod
    def create(cls, title: str, description: str = "") -> "Task":
        """Factory method to create a new task."""
        return cls(
            id=str(uuid.uuid4()),
            title=title,
            description=description
        )

    def to_dict(self) -> dict: ...

    @classmethod
    def from_dict(cls, data: dict) -> "Task": ...

    def mark_updated(self) -> None:
        """Update the updated_at timestamp."""
        self.updated_at = datetime.now().strftime("%Y-%m-%dT%H:%M:%S")

    @property
    def short_id(self) -> str:
        """Return first 8 characters of ID for display."""
        return self.id[:8]
```

#### src/services/task_service.py

```python
"""Business logic for task operations."""

from typing import Optional
from src.models import Task, Priority
from src.exceptions import TaskNotFoundError, AmbiguousIdError, ValidationError


class TaskService:
    """Handles all task-related business logic."""

    def __init__(self, storage: "StorageService") -> None:
        self._storage = storage
        self._tasks: list[Task] = []
        self._load_tasks()

    def _load_tasks(self) -> None: ...
    def _save_tasks(self) -> bool: ...

    # CRUD Operations
    def add_task(self, title: str, description: str = "") -> Task: ...
    def get_task(self, task_id: str) -> Task: ...  # Raises TaskNotFoundError
    def get_all_tasks(self) -> list[Task]: ...
    def update_task(self, task_id: str, title: Optional[str] = None,
                    description: Optional[str] = None) -> Task: ...
    def delete_task(self, task_id: str) -> None: ...

    # Status Operations
    def toggle_complete(self, task_id: str) -> Task: ...
    def set_priority(self, task_id: str, priority: Priority) -> Task: ...

    # Tag Operations
    def add_tag(self, task_id: str, tag: str) -> Task: ...
    def remove_tag(self, task_id: str, tag: str) -> Task: ...

    # Search and Filter
    def search(self, query: str) -> list[Task]: ...
    def filter_by_status(self, completed: bool) -> list[Task]: ...
    def filter_by_priority(self, priority: Priority) -> list[Task]: ...
    def filter_by_tag(self, tag: str) -> list[Task]: ...

    # Sort
    def sort_tasks(self, tasks: list[Task], field: str,
                   reverse: bool = False) -> list[Task]: ...

    # Due Date Operations
    def set_due_date(self, task_id: str, due_date: str) -> Task: ...
    def clear_due_date(self, task_id: str) -> Task: ...
    def get_overdue(self) -> list[Task]: ...
    def get_due_today(self) -> list[Task]: ...
    def get_due_this_week(self) -> list[Task]: ...

    # Recurring Operations
    def set_recurring(self, task_id: str, pattern: Optional[str]) -> Task: ...
    def handle_recurring_completion(self, task: Task) -> Optional[Task]: ...

    # ID Resolution
    def find_by_partial_id(self, partial_id: str) -> Task: ...
```

### 7.3 Constants Definition

```python
# src/utils/constants.py
"""Application constants and configuration."""

from pathlib import Path

# Paths
PROJECT_ROOT = Path(__file__).parent.parent.parent
DATA_DIR = PROJECT_ROOT / "data"
DEFAULT_DATA_FILE = DATA_DIR / "tasks.json"
BACKUP_SUFFIX = ".backup"
TEMP_SUFFIX = ".tmp"

# Validation Limits
MAX_TITLE_LENGTH = 200
MAX_DESCRIPTION_LENGTH = 2000
MAX_TAGS_PER_TASK = 10
MAX_TAG_LENGTH = 50
MIN_SEARCH_LENGTH = 2

# Display
SHORT_ID_LENGTH = 8
TITLE_DISPLAY_LENGTH = 35
DATE_FORMAT = "%Y-%m-%d"
DATETIME_FORMAT = "%Y-%m-%dT%H:%M:%S"
DISPLAY_DATETIME_FORMAT = "%Y-%m-%d %H:%M:%S"

# Exit Codes
EXIT_SUCCESS = 0
EXIT_ERROR = 1

# Validation Patterns
TAG_PATTERN = r"^[a-z0-9][a-z0-9-]{0,49}$"

# Menu Options by Level
LEVEL_1_OPTIONS = {1, 2, 3, 4, 5, 6}
LEVEL_2_OPTIONS = LEVEL_1_OPTIONS | {7, 8, 9, 10, 11, 12}
LEVEL_3_OPTIONS = LEVEL_2_OPTIONS | {13, 14, 15, 16, 17, 18}

# Data Format Version
DATA_VERSION = "1.0.0"
```

---

## 8. Testing Requirements

### 8.1 Test Framework

- **Framework**: `unittest` (standard library)
- **Runner**: `python -m pytest` or `python -m unittest discover`
- **Coverage**: `python -m coverage run -m pytest`

### 8.2 Test Categories

#### Unit Tests

| Test File | Tests | Coverage Target |
|-----------|-------|-----------------|
| `test_task.py` | Task creation, serialization, validation | 100% |
| `test_priority.py` | Priority enum, comparison | 100% |
| `test_task_service.py` | All service methods | 90% |
| `test_storage_service.py` | Load, save, backup, recovery | 90% |
| `test_validators.py` | All validation functions | 100% |
| `test_date_utils.py` | Date parsing, formatting | 100% |

#### Integration Tests

| Test | Description |
|------|-------------|
| `test_full_crud_workflow` | Add → List → View → Update → Complete → Delete |
| `test_persistence_round_trip` | Add tasks → Exit → Restart → Verify tasks exist |
| `test_filter_and_sort_combined` | Apply filters, then sort, verify results |
| `test_recurring_task_flow` | Set recurring → Complete → Verify new task created |
| `test_error_recovery` | Corrupt file → Load → Verify recovery |

### 8.3 Test Case Specifications

#### Task Model Tests

```python
class TestTask:
    def test_create_with_required_fields_only(self):
        """Task can be created with just title."""
        task = Task.create("Buy milk")
        assert task.title == "Buy milk"
        assert task.description == ""
        assert task.completed is False
        assert task.priority == Priority.NONE
        assert task.tags == []
        assert task.due_date is None
        assert task.recurring is None
        assert len(task.id) == 36  # UUID format
        assert task.created_at != ""
        assert task.updated_at != ""

    def test_create_with_all_fields(self):
        """Task can be created with all fields."""
        ...

    def test_to_dict_and_from_dict_roundtrip(self):
        """Task serialization is reversible."""
        original = Task.create("Test", "Description")
        original.priority = Priority.HIGH
        original.tags = ["work", "urgent"]

        data = original.to_dict()
        restored = Task.from_dict(data)

        assert restored.id == original.id
        assert restored.title == original.title
        assert restored.priority == original.priority
        # ... all fields match

    def test_short_id_returns_first_8_chars(self):
        """short_id property returns first 8 characters."""
        task = Task.create("Test")
        assert len(task.short_id) == 8
        assert task.id.startswith(task.short_id)

    def test_mark_updated_changes_timestamp(self):
        """mark_updated() updates the updated_at field."""
        task = Task.create("Test")
        old_updated = task.updated_at
        time.sleep(0.1)
        task.mark_updated()
        assert task.updated_at > old_updated
```

#### TaskService Tests

```python
class TestTaskService:
    def test_add_task_creates_and_persists(self):
        """Adding a task saves it to storage."""
        service = create_test_service()
        task = service.add_task("New task")

        assert task.title == "New task"
        assert len(service.get_all_tasks()) == 1

    def test_get_task_with_partial_id(self):
        """Tasks can be found with partial ID."""
        service = create_test_service()
        task = service.add_task("Test")

        found = service.find_by_partial_id(task.id[:4])
        assert found.id == task.id

    def test_get_task_ambiguous_id_raises(self):
        """Ambiguous partial ID raises AmbiguousIdError."""
        service = create_test_service()
        # Create multiple tasks (IDs might share prefix by chance)
        for _ in range(100):
            service.add_task("Test")

        # This test may need specific setup to guarantee collision
        # or test the logic directly with mocked data

    def test_toggle_complete_flips_status(self):
        """Toggling completed status works both ways."""
        service = create_test_service()
        task = service.add_task("Test")

        assert task.completed is False
        service.toggle_complete(task.id)
        assert task.completed is True
        service.toggle_complete(task.id)
        assert task.completed is False

    def test_search_finds_in_title(self):
        """Search finds matches in title."""
        service = create_test_service()
        service.add_task("Buy groceries")
        service.add_task("Call mom")

        results = service.search("grocery")
        assert len(results) == 1
        assert results[0].title == "Buy groceries"

    def test_search_case_insensitive(self):
        """Search is case-insensitive."""
        service = create_test_service()
        service.add_task("Buy GROCERIES")

        results = service.search("groceries")
        assert len(results) == 1

    def test_filter_by_status_completed(self):
        """Filter returns only completed tasks."""
        service = create_test_service()
        task1 = service.add_task("Task 1")
        task2 = service.add_task("Task 2")
        service.toggle_complete(task1.id)

        results = service.filter_by_status(completed=True)
        assert len(results) == 1
        assert results[0].id == task1.id
```

### 8.4 Test Coverage Requirements

| Module | Minimum | Target |
|--------|---------|--------|
| `src/models/` | 100% | 100% |
| `src/services/` | 90% | 95% |
| `src/utils/` | 90% | 95% |
| `src/ui/` | 70% | 80% |
| `src/exceptions.py` | 100% | 100% |
| **Overall** | **85%** | **90%** |

---

## 9. Acceptance Criteria

### 9.1 Level 1 Completion Checklist

- [ ] `main.py` runs without errors
- [ ] Option 1 (Add): Creates task, saves to JSON, displays confirmation
- [ ] Option 2 (List): Shows all tasks in formatted table
- [ ] Option 3 (View): Shows full task details for given ID
- [ ] Option 4 (Update): Modifies title/description, preserves other fields
- [ ] Option 5 (Delete): Requires confirmation, removes task permanently
- [ ] Option 6 (Toggle): Flips completed status
- [ ] Option h (Help): Shows command descriptions
- [ ] Option 0 (Exit): Exits cleanly with goodbye message
- [ ] Tasks persist after exit and restart
- [ ] Invalid inputs show clear error messages
- [ ] Partial ID matching works (4+ chars)
- [ ] All unit tests pass
- [ ] Test coverage ≥ 85%

### 9.2 Level 2 Completion Checklist

- [ ] All Level 1 criteria met
- [ ] Option 7 (Priority): Sets HIGH/MEDIUM/LOW/NONE
- [ ] Option 8 (Add Tag): Adds valid tag, rejects invalid
- [ ] Option 9 (Remove Tag): Removes by name or number
- [ ] Option 10 (Search): Finds in title, description, tags
- [ ] Option 11 (Filter): Filters by status, priority, tag
- [ ] Option 12 (Sort): Sorts by all specified fields
- [ ] Tags are always lowercase
- [ ] Duplicate tags are rejected
- [ ] Max 10 tags enforced
- [ ] Search minimum 2 chars enforced
- [ ] All new unit tests pass

### 9.3 Level 3 Completion Checklist

- [ ] All Level 2 criteria met
- [ ] Option 13 (Set Due): Sets date in YYYY-MM-DD format
- [ ] Option 14 (Clear Due): Removes due date (and recurring if set)
- [ ] Option 15 (Overdue): Shows only overdue incomplete tasks
- [ ] Option 16 (Due Today): Shows only tasks due today
- [ ] Option 17 (Due Week): Shows tasks due in next 7 days
- [ ] Option 18 (Recurring): Sets daily/weekly/monthly pattern
- [ ] Recurring requires due_date
- [ ] Completing recurring task creates new instance
- [ ] New recurring instance has correct next due date
- [ ] Startup shows reminders if overdue/due-today exist
- [ ] Past dates show warning but allow setting
- [ ] All new unit tests pass
- [ ] Integration tests pass

### 9.4 Final Quality Checklist

- [ ] No `# type: ignore` comments without justification
- [ ] No bare `except:` clauses
- [ ] All functions have type hints
- [ ] All public functions have docstrings
- [ ] No hardcoded values (all in constants.py)
- [ ] PEP 8 compliant (verified with flake8/pylint)
- [ ] No security vulnerabilities (no eval, exec, shell commands)
- [ ] No network access
- [ ] All error messages are user-friendly
- [ ] README.md documents installation and usage

---

## Version History

| Version | Date | Author | Changes |
|---------|------|--------|---------|
| 1.0.0 | 2024-01-01 | - | Initial specification |
| 2.0.0 | 2024-01-15 | - | Clarified all ambiguities, added detailed flows, aligned with constitution |

---

*This specification is the authoritative implementation guide.*
*All code MUST satisfy these specifications exactly.*
*In case of conflict with constitution.md, the constitution prevails.*
